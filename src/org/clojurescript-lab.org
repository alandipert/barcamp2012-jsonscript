#+TITLE:LAB: Rock, Paper, Scissors Redux
#+TAGS: fold(f)

In this lab, we will use the Rock, Paper, Scissors code that we wrote
in the Polymorphism lab to create a browser-based game.

Before you start working though the exercises below, setup and run the
application which will host our ClojureScript project.

* Run the application

On Unix-like systems:

#+begin_example
  cd clojurescript-lab
  script/run
#+end_example

On Windows systems:

#+begin_example
  cd clojurescript-lab
  script/run.bat
#+end_example

This will start the server, open your default browser and give you a
working REPL. If your browser does not start, open it and go to
<http://localhost:8080>.

In the browser, read about the application that we are going to
build. When you are ready, continue with the lab exercises below.

* Bonus: Browser-connected REPL

For this lab, you don't need to use a browser-connect REPL, but if you
would like to work with your application from the REPL, you may enter

#+begin_src clojure
(cljs-repl)
#+end_src

in the REPL to start a ClojureScript REPL. After starting the REPL you
will need to refresh the Development page to connect. You can test
your connection by typing the following into the REPL:

#+begin_src clojure
(js/alert "Hello World")
#+end_src

* Add some state

In this application we will use a single atom to store state. Define
an atom named =game-state= as well as a map of player names to Player
instances.

** Solution                                                            :fold:

#+begin_src clojure
;;; State

(def game-state (atom nil))

(def players {"Random" (rps/->Random)
              "Stubborn" (rps/->Stubborn :rock)
              "Mean" (rps/->Mean nil)})
#+end_src

* React to state changes by rendering the current state

A view is a visual representation of the current state of the
application. When the state changes, we would like the views to be
updated. This is a perfect opportunity to use a Clojure watcher.

In our state we will have a key named =:phase= that we will use to
determine which view to draw. The phases will be =:choose-player=,
=:choose-weapon= and =:showdown=.

Create a multimethod named =render= which will take the game state and
dispatch on the =:phase=. Create a default implementation which displays
the state on the screen.

HINT: The code to add something to the DOM and print the state will
look like this:

#+begin_src clojure
(set-html! (by-id "content")
           (str "This view is not implemented for:" (pr-str game)))
#+end_src

Use the Domina function =set-html!= to set the HTML content of an
element and the =by-id= function to find an element by its id.

Use the Clojure =pr-str= function to print a JavaScript value as
Clojure data.

** Solution                                                            :fold:

#+begin_src clojure
;;; Rendering

(defmulti render :phase)

(defmethod render :default [game]
  (set-html! (by-id "content")
             (str "This view is not implemented for:" (pr-str game))))
#+end_src

* Watch the state

Update the main function by adding a watcher to the =game-state= atom. The
watcher should call the =render= function passing the new state.

Refresh the browser to see your changes. You should now see the state
of the application being printed to the screen.

** Solution                                                            :fold:

#+begin_src clojure
;;; Main

(defn react-to-state-change [_ _ _ n]
  (render n))

(defn ^:export main []  
  (add-watch game-state :game-state-watcher react-to-state-change)
  (swap! game-state assoc :phase :choose-player))
#+end_src

* Use pure functions to update state

In the code that follows, we will try to write pure functions for
updating state and keep them separate from the code that has
side-effects. There are headings in the source file for /Pure functions/
and for /Actions/. /Actions/ are things which users do that have
side-effects.

As a small example, create a function named =next-phase= that will
take and game state and a phase and will return a new game
state. Update the =main= function to use this function instead of
calling assoc directly.

** Solution                                                            :fold:

#+begin_src clojure
;;; Pure functions

(defn next-phase [game p]
  (assoc game :phase p))

;;; Main

(defn ^:export main []
  (add-watch game-state :game-state-watcher react-to-state-change)
  (swap! game-state next-phase :choose-player))

#+end_src

* Iterations

The remaining steps for building our application will involve three
iterations where we do the same thing each time. In each iteration we
first render a view and then we setup actions which will modify the
application's state.
              
* Iteration 1 - Select an opponent

* Render the initial =:choose-player= state

All the templates that we will use come from the =lab.html= file that
you looked at earlier. We can get these templates by calling
=(templates/snippets)=. Add the following code in the /Render/ section of
the source file:

#+begin_src clojure
;;; Render

(def snippets (templates/snippets))
#+end_src

=snippets= is a map. We can get the =:choose-opponent= template from
this map and add it to the DOM. Create a =render= method that will add
this template to the DOM inside of the element with the id "content".

Also, create buttons for each of the players. You will again need to
use the functions =set-html!=, =by-id= and =append!= as well as the utility
functions =button= and =on-click=.

Refresh the browser to see the results of these changes.

** Solution                                                            :fold:

#+begin_src clojure
;;; Render

(defmethod render :choose-player [game]
  (set-html! (by-id "content") (:choose-opponent snippets))
  (set-html! (by-id "players") "")
  (doseq [p2 (map button (sort (keys players)))]
    (append! (by-id "players") p2)
    (on-click p2 (fn [target] (js/alert (.-value target))))))
#+end_src

* Respond to button clicks by changing state

We should now have a working view that displays an alert when a button
is clicked. Add a =player-selected!= action which will add the
selected player to the state. The state should contain keys =:p2-name=
for the selected player's name and =p2= for the instance of that
player.

This action should also set the =:phase= to =:choose-weapon=.

** Solution                                                            :fold:

#+begin_src clojure
;;; Pure Functions

(defn player-selected [game p2-name p2]
  (-> game
      (assoc :p2-name p2-name :p2 p2)
      (next-phase :choose-weapon)))

;;; Actions

(defn player-selected! [player-name]
  (swap! game-state player-selected player-name (get players player-name)))

;;; Render

(defmethod render :choose-player [game]
  (set-html! (by-id "content") (:choose-opponent snippets))
  (set-html! (by-id "players") "")
  (doseq [p2 (map button (sort (keys players)))]
    (append! (by-id "players") p2)
    (on-click p2 (fn [target] (player-selected! (.-value target))))))
#+end_src

* Iteration 2 - Choose your Weapon

If you refresh the page and run the application at this point, you
should be able to make it through the first view and then see the
changed state printed to the screen. We need to repeat this process
two more times to complete the remaining two views.

* Render the =:choose-weapon= state

Use the =:make-choice= template to create a view for the
=:choose-weapon= state. When you click on an element, show an alert
which indicates which element you have clicked.

Refresh the browser to see the results of these changes.

** Solution                                                            :fold:

#+begin_src clojure
;;; Render

(defmethod render :choose-weapon [game]
  (set-html! (by-id "content") (:make-choice snippets))
  (doseq [c [:rock :paper :scissors]]
    (on-click (by-id (name c)) (fn [_] (js/alert c)))))
#+end_src

* Respond to a choice

Add a =weapon-selected= action which adds the chosen weapon to the
state and changes the =:phase= to =:showdown=.

Refresh the browser to see the results of these changes.

** Solution                                                            :fold:

#+begin_src clojure
;;; Pure functions

(defn weapon-selected [game my-choice]
  (-> game
      (assoc :my-choice my-choice)
      (next-phase :showdown)))

;;; Actions

(defn weapon-selected! [choice]
  (swap! game-state weapon-selected choice))

;;; Render

(defmethod render :choose-weapon [game]
  (set-html! (by-id "content") (:make-choice snippets))
  (doseq [c [:rock :paper :scissors]]
    (on-click (by-id (name c)) (fn [_] (weapon-selected! c)))))
#+end_src

* Iteration 3 - Showdown

* Play a game

After we choose a weapon, we are ready to play a game. Update the
=weapon-selected= function to play one round of the game and update
the state. After a game, the state should contain the keys
=:game-over-message=, =:p2-choice=, =:result= as well as a =:p2= key
with updated player. The =:result= key will contain the winning choice.

Refresh the browser to see the results of these changes.

** Solution                                                            :fold:

#+begin_src clojure
;;; Pure functions
(defn record-winner [{:keys [my-choice p2-choice result] :as game}]
  (assoc game :game-over-message
         (cond (= my-choice p2-choice) "It's a tie!"
               (= my-choice result) "You win!"
               :else "You lose!")))

(defn update-p2-strategy [{:keys [my-choice p2 p2-choice result] :as game}]
  (assoc game :p2 (rps/update-strategy p2 p2-choice my-choice)))

(defn showdown [{:keys [my-choice p2] :as game}]
  (let [p2-choice (rps/choose p2)
        result (rps/winner my-choice p2-choice)]
    (-> game
        (assoc :p2-choice p2-choice :result result)
        record-winner
        update-p2-strategy)))

(defn weapon-selected [game my-choice]
  (-> game
      (assoc :my-choice my-choice)
      showdown
      (next-phase :showdown)))
#+end_src

* Render game results

Create a view which renders the results of the game. Use the
=:showdown= template for the view. There are also templates for
=:rock=, =:paper= and =:scissors=.

Refresh the browser to see the results of these changes.

** Solution                                                            :fold:

#+begin_src clojure
;;; Render

(defmethod render :showdown [game]
  (set-html! (by-id "content") (:showdown snippets))
  (set-html! (by-id "opponent") (:p2-name game))
  (set-html! (by-id "your-choice") (get snippets (:my-choice game)))
  (set-html! (by-id "p2-choice") (get snippets (:p2-choice game)))
  (set-html! (by-id "game-over-message") (:game-over-message game)))
#+end_src

* Add new-game and new-opponent actions

Finally, create two new actions for choosing a new player and choosing
a new weapon. Modify the showdown view to enable these actions.

** Solution                                                            :fold:

#+begin_src clojure
;;; Actions

(defn new-game! []
  (swap! game-state next-phase :choose-weapon))

(defn new-opponent! []
  (swap! game-state next-phase :choose-player))

;;; Render

(defmethod render :showdown [game]
  (set-html! (by-id "content") (:showdown snippets))
  (set-html! (by-id "opponent") (:p2-name game))
  (set-html! (by-id "your-choice") (get snippets (:my-choice game)))
  (set-html! (by-id "p2-choice") (get snippets (:p2-choice game)))
  (set-html! (by-id "game-over-message") (:game-over-message game))
  (on-click (by-id "new-game-button") (fn [_] (new-game!)))
  (on-click (by-id "new-opponent-button") (fn [_] (new-opponent!))))
#+end_src
